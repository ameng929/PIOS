/*
 * Trap handler entry and exit code, written in assembly language.
 *
 * Copyright (C) 1997 Massachusetts Institute of Technology
 * See section "MIT License" in the file LICENSES for licensing terms.
 *
 * Derived from the MIT Exokernel and JOS.
 * Adapted for PIOS by Bryan Ford at Yale University.
 */

#include <inc/mmu.h>
#include <inc/trap.h>

#include <kern/cpu.h>



/* The TRAPHANDLER macro defines a globally-visible function for handling
 * a trap.  It pushes a trap number onto the stack, then jumps to _alltraps.
 * Use TRAPHANDLER for traps where the CPU automatically pushes an error code.
 */ 
#define TRAPHANDLER(name, num)						\
	.globl name;		/* define global symbol for 'name' */	\
	.type name, @function;	/* symbol type is function */		\
	.align 2;		/* align function definition */		\
	name:			/* function starts here */		\
	pushl $(num);							\
	jmp _alltraps

/* Use TRAPHANDLER_NOEC for traps where the CPU doesn't push an error code.
 * It pushes a 0 in place of the error code, so the trap frame has the same
 * format in either case.
 */
#define TRAPHANDLER_NOEC(name, num)					\
	.globl name;							\
	.type name, @function;						\
	.align 2;							\
	name:								\
	pushl $0;							\
	pushl $(num);							\
	jmp _alltraps

.text

/*
 * Lab 1: Your code here for generating entry points for the different traps.
 */
//TRAPHANDLER_NOEC(trap_divide, T_DIVIDE)
//TRAPHANDLER_NOEC(trap_debug,  T_DEBUG)
//TRAPHANDLER_NOEC(trap_nmi,    T_NMI)
//TRAPHANDLER_NOEC(trap_brkpt,  T_BRKPT)
//TRAPHANDLER_NOEC(trap_oflow,  T_OFLOW)
//TRAPHANDLER_NOEC(trap_bound,  T_BOUND)
//TRAPHANDLER_NOEC(trap_illop,  T_ILLOP)
//TRAPHANDLER_NOEC(trap_device, T_DEVICE)
//TRAPHANDLER_NOEC(trap_dblflt, T_DBLFLT)

//TRAPHANDLER	(trap_tss,    T_TSS)
//TRAPHANDLER	(trap_segnp,  T_SEGNP)
//TRAPHANDLER	(trap_stack,  T_STACK)
//TRAPHANDLER	(trap_gpflt,  T_GPFLT)
//TRAPHANDLER	(trap_pgflt,  T_PGFLT)

//TRAPHANDLER_NOEC(trap_fperr,  T_FPERR)
//TRAPHANDLER_NOEC(trap_align,  T_ALIGN)

//TRAPHANDLER_NOEC(trap_mchk,   T_MCHK)
//TRAPHANDLER_NOEC(trap_simd,   T_SIMD)
//TRAPHANDLER	(trap_secev,  T_SECEV)

//TRAPHANDLER_NOEC(trap_irq_timer,    T_IRQ0+0)
//TRAPHANDLER_NOEC(trap_irq_kdb,      T_IRQ0+1)
//TRAPHANDLER_NOEC(trap_irq_serial,   T_IRQ0+4)
//TRAPHANDLER_NOEC(trap_irq_spurious, T_IRQ0+7)
//TRAPHANDLER_NOEC(trap_irq_ide,      T_IRQ0+14)

//TRAPHANDLER_NOEC(trap_syscall, T_SYSCALL)
//TRAPHANDLER_NOEC(trap_ltimer,  T_LTIMER)
//TRAPHANDLER_NOEC(trap_lerror,  T_LERROR)
//TRAPHANDLER	(trap_default, T_DEFAULT)
//TRAPHANDLER	(trap_icnt,    T_ICNT)

TRAPHANDLER_NOEC(vector0,0)		// divide error
TRAPHANDLER_NOEC(vector1,1)		// debug exception
TRAPHANDLER_NOEC(vector2,2)		// non-maskable interrupt
TRAPHANDLER_NOEC(vector3,3)		// breakpoint
TRAPHANDLER_NOEC(vector4,4)		// overflow
TRAPHANDLER_NOEC(vector5,5)		// bounds check
TRAPHANDLER_NOEC(vector6,6)		// illegal opcode
TRAPHANDLER_NOEC(vector7,7)		// device not available 
TRAPHANDLER(vector8,8)			// double fault
TRAPHANDLER_NOEC(vector9,9)		// reserved (not generated by recent processors)
TRAPHANDLER(vector10,10)		// invalid task switch segment
TRAPHANDLER(vector11,11)		// segment not present
TRAPHANDLER(vector12,12)		// stack exception
TRAPHANDLER(vector13,13)		// general protection fault
TRAPHANDLER(vector14,14)		// page fault
TRAPHANDLER_NOEC(vector15,15)		// reserved
TRAPHANDLER_NOEC(vector16,16)		// floating point error
TRAPHANDLER(vector17,17)		// alignment check
TRAPHANDLER_NOEC(vector18,18)		// machine check
TRAPHANDLER_NOEC(vector19,19)		// SIMD floating point error

/*
 * Lab 1: Your code here for _alltraps
 */
.globl	_alltraps
.type	_alltraps,@function
.p2align 4, 0x90
_alltraps:
	pushl %ds
	pushl %es
	pushl %fs
	pushl %gs
	pushal

	movw $CPU_GDT_KDATA, %ax
	movw %ax, %ds
	movw %ax, %es
	//there is no SEG_KCPU in PIOS ,
	//so do not need to reset %fs , %gs

	pushl %esp //oesp
	call trap
	//addl $4, %esp //calling convention

//
// Trap return code.
// C code in the kernel will call this function to return from a trap,
// providing the
// Restore the CPU state from a given trapframe struct
// and return from the trap using the processor's 'iret' instruction.
// This function does not return to the caller,
// since the new CPU state this function loads
// replaces the caller's stack pointer and other registers.
//
.globl	trap_return
.type	trap_return,@function
.p2align 4, 0x90		/* 16-byte alignment, nop filled */
trap_return:
/*
 * Lab 1: Your code here for trap_return
 */ //1: jmp 1b // just spin
	movl 4(%esp), %esp
	//this step has been done in _alltrap
	//popl %esp
	popal 
	popl %gs
	popl %fs
	popl %es
	popl %ds
	addl $8, %esp
	iret

.data
.globl vectors
vectors:
	.long vector0
	.long vector1
	.long vector2
	.long vector3
	.long vector4
	.long vector5
	.long vector6
	.long vector7
	.long vector8
	.long vector9
	.long vector10
	.long vector11
	.long vector12
	.long vector13
	.long vector14
	.long vector15
	.long vector16
	.long vector17
	.long vector18
	.long vector19
